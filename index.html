
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>図形を手軽に作るやつ</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    // Immediately-invoked function expression to set the initial theme
    (function() {
      try {
        var theme = localStorage.getItem('theme');
        var prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

        if (theme === 'dark' || (!theme && prefersDark)) {
          document.documentElement.classList.add('dark');
        } else {
          document.documentElement.classList.remove('dark');
        }
      } catch (e) {
        console.error('Error applying initial theme:', e);
      }
    })();
  </script>
  <style>
    body { 
      margin: 0; 
      font-family: sans-serif;
      background-color: #F3F4F6; /* gray-100 */
      color: #1F2937; /* slate-900 (default text for light mode) */
    }
    html.dark body {
      background-color: #0F172A; /* slate-900 */
      color: #F8FAFC; /* slate-50 (default text for dark mode) */
    }

    /* Custom scrollbar */
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: #e5e7eb; border-radius: 10px; }
    html.dark ::-webkit-scrollbar-track { background: #374151; }
    ::-webkit-scrollbar-thumb { background: #9ca3af; border-radius: 10px; }
    html.dark ::-webkit-scrollbar-thumb { background: #6b7280; }
    ::-webkit-scrollbar-thumb:hover { background: #6b7280; }
    html.dark ::-webkit-scrollbar-thumb:hover { background: #4b5563; }
    
    input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
    input[type="color"]::-webkit-color-swatch { border: none; border-radius: 0.125rem; }
    input[type="color"] { width: 100%; height: 2.5rem; padding: 0.25rem; box-sizing: border-box; cursor: pointer; }

    /* Theme-dependent styles */
    #app-title { color: #6D28D9; /* purple-700 */ }
    html.dark #app-title { color: #A78BFA; /* purple-400 */ }
    
    #app-description { color: #475569; /* slate-600 */ }
    html.dark #app-description { color: #94A3B8; /* slate-400 */ }

    #theme-toggle-button { background-color: transparent; }
    #theme-toggle-button:hover { background-color: #E5E7EB; /* gray-200 */ }
    html.dark #theme-toggle-button:hover { background-color: #334155; /* slate-700 */ }
    
    /* Sun/Moon icon colors handled by JS injection now match general text color expectations */
    html.dark #theme-toggle-button svg { color: #FDE047; /* yellow-400 */ }
    #theme-toggle-button svg { color: #334155; /* slate-700 */ }


    .controls-container { /* lg:w-1/3 equivalent styling for its child */
      background-color: #FFFFFF; /* white */
      border: 1px solid #D1D5DB; /* gray-300 */
    }
    html.dark .controls-container {
      background-color: #1E293B; /* slate-800 */
      border: 1px solid #334155; /* slate-700 */
    }

    .controls-section-header {
      color: #7C3AED; /* purple-600 */
      border-bottom: 1px solid #D1D5DB; /* gray-300 */
    }
    html.dark .controls-section-header {
      color: #A78BFA; /* purple-400 */
      border-bottom: 1px solid #334155; /* slate-700 */
    }

    label.control-label { color: #374151; /* slate-700 */ }
    html.dark label.control-label { color: #CBD5E1; /* slate-300 */ }

    select.control-input, input[type="range"].control-input {
      background-color: #F9FAFB; /* gray-50 */
      border: 1px solid #D1D5DB; /* gray-300 */
      color: #1F2937; /* slate-900 */
    }
    html.dark select.control-input, html.dark input[type="range"].control-input {
      background-color: #334155; /* slate-700 */
      border: 1px solid #475569; /* slate-600 */
      color: #F8FAFC; /* white */
    }
    select.control-input:focus, input[type="range"].control-input:focus {
      outline: 2px solid transparent;
      outline-offset: 2px;
      border-color: #6366F1; /* indigo-500 */
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.5);
    }
    html.dark select.control-input:focus, html.dark input[type="range"].control-input:focus {
      border-color: #A78BFA; /* purple-500 */
      box-shadow: 0 0 0 3px rgba(167, 139, 250, 0.5);
    }
    
    input[type="checkbox"].control-checkbox {
      color: #4F46E5; /* indigo-600 */
      background-color: #F3F4F6; /* gray-100 */
      border-color: #D1D5DB; /* gray-300 */
    }
    input[type="checkbox"].control-checkbox:focus {
        ring: #4F46E5; /* indigo-500 */
        ring-offset: #ffffff; /* white */
    }
    html.dark input[type="checkbox"].control-checkbox {
      color: #7C3AED; /* purple-600 */
      background-color: #334155; /* slate-700 */
      border-color: #475569; /* slate-600 */
    }
    html.dark input[type="checkbox"].control-checkbox:focus {
        ring: #7C3AED; /* purple-500 */
        ring-offset: #1E293B; /* slate-800 */
    }
    
    input[type="color"].control-input {
      background-color: #F9FAFB; /* gray-50 */
      border: 1px solid #D1D5DB; /* gray-300 */
    }
    html.dark input[type="color"].control-input {
      background-color: #334155; /* slate-700 */
      border: 1px solid #475569; /* slate-600 */
    }

    input[type="range"].control-input { /* Accent for range slider thumb */
       accent-color: #4F46E5; /* indigo-600 */
    }
    html.dark input[type="range"].control-input {
       accent-color: #A78BFA; /* purple-500 */
    }
    
    #canvas-render-container {
      background-color: #FFFFFF; /* white */
      border: 1px solid #D1D5DB; /* gray-300 */
    }
    html.dark #canvas-render-container {
      background-color: #1E293B; /* slate-800 */
      border: 1px solid #334155; /* slate-700 */
    }
    #shapeCanvas {
      background-color: transparent;
      /* Tailwind's shadow-inner: box-shadow: inset 0 2px 4px 0 rgb(0 0 0 / 0.05); */
      box-shadow: inset 0 2px 4px 0 rgba(0,0,0,0.05);
    }
    html.dark #shapeCanvas {
      /* A slightly different inner shadow for dark mode if desired, or none */
      box-shadow: inset 0 2px 4px 0 rgba(0,0,0,0.1); 
    }

    #downloadButton {
      background-color: #EC4899; /* pink-500 */
      color: #FFFFFF; /* white */
    }
    #downloadButton:hover {
      background-color: #DB2777; /* pink-600 */
    }
    html.dark #downloadButton {
      background-color: #D946EF; /* fuchsia-500 */
    }
    html.dark #downloadButton:hover {
      background-color: #C026D3; /* fuchsia-600 */
    }
    #downloadButton:focus {
        outline: 2px solid transparent;
        outline-offset: 2px;
        box-shadow: 0 0 0 3px rgba(236, 72, 153, 0.5); /* ring-pink-400 opacity 75 */
    }
    html.dark #downloadButton:focus {
        box-shadow: 0 0 0 3px rgba(217, 70, 239, 0.5); /* ring-fuchsia-500 opacity 75 */
    }

    .footer-text { color: #475569; /* slate-600 */ }
    html.dark .footer-text { color: #64748B; /* slate-500 */ }

  </style>
</head>
<body class="text-base"> <!-- Base text color is now handled by body style above -->

  <div class="min-h-screen flex flex-col items-center p-4 sm:p-8">
    <header class="w-full max-w-6xl mb-8 flex justify-between items-center">
      <div class="text-center flex-grow">
        <h1 id="app-title" class="text-4xl sm:text-5xl font-bold tracking-tight">
          図形を手軽に作るやつ
        </h1>
        <p id="app-description" class="mt-2 text-lg">正多角形・正円を作るだけのアプリです。</p>
      </div>
      <button id="theme-toggle-button" class="p-2 rounded-full" aria-label="テーマを切り替え">
        <!-- SVG icons will be injected by JS -->
      </button>
    </header>

    <div class="w-full max-w-6xl flex flex-col lg:flex-row gap-8">
      <div class="lg:w-1/3 controls-container rounded-xl p-6">
        <div id="controls-panel" class="space-y-6">
          <div>
            <h3 class="text-xl font-semibold mb-3 pb-2 controls-section-header">一般設定</h3>
            <div class="mb-4">
              <label for="shapeType" class="block text-sm font-medium mb-1.5 control-label">シェイプの種類</label>
              <select id="shapeType" class="w-full p-2.5 rounded-md control-input">
                <option value="circle">円</option>
                <option value="polygon">多角形</option>
              </select>
            </div>
            <div class="mb-4">
              <label for="size" class="block text-sm font-medium mb-1.5 control-label">サイズ (ピクセル)</label>
              <select id="size" class="w-full p-2.5 rounded-md control-input"></select>
            </div>
          </div>

          <div id="fill-controls-section">
            <h3 class="text-xl font-semibold mb-3 pb-2 controls-section-header">塗りつぶし設定</h3>
            <div class="mb-4 flex items-center">
              <input type="checkbox" id="fillEnabled" class="w-5 h-5 rounded mr-2 control-checkbox focus:ring-2 focus:ring-offset-2">
              <label for="fillEnabled" class="text-sm font-medium control-label">塗りつぶしを有効にする</label>
            </div>
            <div id="fill-settings" class="hidden">
              <div class="mb-4">
                <label for="fillColor" class="block text-sm font-medium mb-1.5 control-label">塗りつぶしの色</label>
                <input type="color" id="fillColor" class="rounded-md control-input">
              </div>
              <div class="mb-4">
                <label for="fillOpacity" class="block text-sm font-medium mb-1.5 control-label">塗りつぶしの透明度: <span id="fillOpacityValue">1.00</span></label>
                <input type="range" id="fillOpacity" min="0" max="1" step="0.01" class="w-full h-2 rounded-lg appearance-none cursor-pointer control-input">
              </div>
            </div>
          </div>
          
          <div id="stroke-controls-section">
            <h3 class="text-xl font-semibold mb-3 pb-2 controls-section-header">線設定</h3>
            <div class="mb-4 flex items-center">
              <input type="checkbox" id="strokeEnabled" class="w-5 h-5 rounded mr-2 control-checkbox focus:ring-2 focus:ring-offset-2">
              <label for="strokeEnabled" class="text-sm font-medium control-label">線を有効にする</label>
            </div>
            <div id="stroke-settings" class="hidden">
              <div class="mb-4">
                <label for="strokeColor" class="block text-sm font-medium mb-1.5 control-label">線の色</label>
                <input type="color" id="strokeColor" class="rounded-md control-input">
              </div>
              <div class="mb-4">
                <label for="strokeWidth" class="block text-sm font-medium mb-1.5 control-label">線の太さ (ピクセル)</label>
                <select id="strokeWidth" class="w-full p-2.5 rounded-md control-input"></select>
              </div>
            </div>
          </div>

          <div id="polygon-specific-settings" class="hidden">
            <h3 class="text-xl font-semibold mb-3 pb-2 controls-section-header">多角形設定</h3>
            <div class="mb-4">
              <label for="polygonSides" class="block text-sm font-medium mb-1.5 control-label">辺の数: <span id="polygonSidesValue">5</span></label>
              <input type="range" id="polygonSides" min="3" max="20" step="1" class="w-full h-2 rounded-lg appearance-none cursor-pointer control-input">
            </div>
            <div class="mb-4">
              <label for="cornerRadiusLevel" class="block text-sm font-medium mb-1.5 control-label">角の丸み</label>
              <select id="cornerRadiusLevel" class="w-full p-2.5 rounded-md control-input">
                <option value="none">なし</option>
                <option value="small">小</option>
                <option value="medium">中</option>
                <option value="large">大</option>
              </select>
            </div>
          </div>
        </div>
      </div>

      <div class="lg:w-2/3 flex flex-col items-center gap-6">
        <div id="canvas-render-container" class="rounded-xl p-3 sm:p-4">
          <canvas id="shapeCanvas" class="rounded-md" style="display: block;"></canvas>
        </div>
        <button id="downloadButton" class="px-8 py-3 font-semibold rounded-lg transition-colors duration-150">
          シェイプをダウンロード (PNG)
        </button>
      </div>
    </div>
    <footer class="mt-12 text-center text-sm footer-text">
      <p>&copy; <span id="currentYear"></span> 図形を手軽に作るやつ. All rights reserved.</p>
    </footer>
  </div>

<script>
  // Constants and Enums
  const ShapeType = { CIRCLE: 'circle', POLYGON: 'polygon' };
  const CornerRadiusLevel = { NONE: 'none', SMALL: 'small', MEDIUM: 'medium', LARGE: 'large' };
  const Theme = { LIGHT: 'light', DARK: 'dark' };

  const SIZES = [100, 200, 300, 400, 500, 600, 700, 800, 900];
  const STROKE_WIDTHS = [0, 1, 2, 3, 4, 5, 8, 10, 12, 15, 20];
  const POLYGON_SIDES_MIN = 3;
  const POLYGON_SIDES_MAX = 20;

  const DEFAULT_SHAPE_CONFIG = {
    shapeType: ShapeType.CIRCLE,
    size: 300,
    fillEnabled: true,
    fillColor: '#3B82F6', // Tailwind blue-500
    fillOpacity: 1.0,
    strokeEnabled: false,
    strokeColor: '#1F2937', // Tailwind gray-800
    strokeWidth: 2,
    polygonSides: 5,
    cornerRadiusLevel: CornerRadiusLevel.NONE,
  };

  // Application State
  let currentConfig = { ...DEFAULT_SHAPE_CONFIG };
  let currentTheme = Theme.LIGHT; 

  // DOM Elements
  const dom = {
    shapeType: document.getElementById('shapeType'),
    size: document.getElementById('size'),
    fillEnabled: document.getElementById('fillEnabled'),
    fillSettings: document.getElementById('fill-settings'),
    fillColor: document.getElementById('fillColor'),
    fillOpacity: document.getElementById('fillOpacity'),
    fillOpacityValue: document.getElementById('fillOpacityValue'),
    strokeEnabled: document.getElementById('strokeEnabled'),
    strokeSettings: document.getElementById('stroke-settings'),
    strokeColor: document.getElementById('strokeColor'),
    strokeWidth: document.getElementById('strokeWidth'),
    polygonSpecificSettings: document.getElementById('polygon-specific-settings'),
    polygonSides: document.getElementById('polygonSides'),
    polygonSidesValue: document.getElementById('polygonSidesValue'),
    cornerRadiusLevel: document.getElementById('cornerRadiusLevel'),
    canvasRenderContainer: document.getElementById('canvas-render-container'), // Changed from canvasContainer
    canvas: document.getElementById('shapeCanvas'),
    downloadButton: document.getElementById('downloadButton'),
    themeToggleButton: document.getElementById('theme-toggle-button'),
    currentYear: document.getElementById('currentYear'),
    // For toggling visibility of sections
    fillControlsSection: document.getElementById('fill-controls-section'),
    strokeControlsSection: document.getElementById('stroke-controls-section'),

  };

  const moonIconSvg = `<svg class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M21.752 15.002A9.72 9.72 0 0 1 18 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 0 0 3 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 0 0 9.002-5.998Z" /></svg>`;
  const sunIconSvg = `<svg class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m6.364.386-1.591 1.591M21 12h-2.25m-.386 6.364-1.591-1.591M12 18.75V21m-6.364-.386 1.591-1.591M3 12h2.25m.386-6.364 1.591 1.591M12 12a2.25 2.25 0 0 0-2.25 2.25c0 1.31.316 2.506.865 3.565A2.25 2.25 0 0 0 12 12Zm0 0a2.25 2.25 0 0 1 2.25 2.25c0 1.31-.316 2.506-.865 3.565A2.25 2.25 0 0 1 12 12M12 6.75a2.25 2.25 0 1 0 0 4.5 2.25 2.25 0 0 0 0-4.5Z" /></svg>`;


  function drawShape() {
    const canvas = dom.canvas;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    let actualCornerRadius = 0;
    const {
      shapeType, size, fillEnabled, fillColor, fillOpacity,
      strokeEnabled, strokeColor, strokeWidth: configStrokeWidth,
      polygonSides, cornerRadiusLevel,
    } = currentConfig;

    canvas.width = size;
    canvas.height = size;
    
    const canvasPadding = parseFloat(getComputedStyle(dom.canvasRenderContainer).paddingLeft) + parseFloat(getComputedStyle(dom.canvasRenderContainer).paddingRight);
    dom.canvasRenderContainer.style.width = `${size + canvasPadding}px`; 
    dom.canvasRenderContainer.style.height = `${size + canvasPadding}px`;


    ctx.clearRect(0, 0, size, size);
    const centerX = size / 2;
    const centerY = size / 2;
    const effectiveStrokeWidth = strokeEnabled && configStrokeWidth > 0 ? configStrokeWidth : 0;
    let shapeRadius = (size / 2) - (effectiveStrokeWidth / 2);
    if (shapeRadius < 0) shapeRadius = 0;

    ctx.beginPath();

    if (shapeType === ShapeType.CIRCLE) {
      ctx.arc(centerX, centerY, shapeRadius, 0, 2 * Math.PI);
    } else if (shapeType === ShapeType.POLYGON && polygonSides >= 3) {
      const angleStep = (2 * Math.PI) / polygonSides;
      const baseRadiusForRounding = shapeRadius * 0.25; 

      if (cornerRadiusLevel === CornerRadiusLevel.SMALL) actualCornerRadius = baseRadiusForRounding * 0.3;
      else if (cornerRadiusLevel === CornerRadiusLevel.MEDIUM) actualCornerRadius = baseRadiusForRounding * 0.6;
      else if (cornerRadiusLevel === CornerRadiusLevel.LARGE) actualCornerRadius = baseRadiusForRounding * 1.0;
      
      const sideLengthApprox = 2 * shapeRadius * Math.sin(angleStep / 2);
      let maxPossibleArcRadius = (sideLengthApprox / 2.0) - 0.001; 
      if (maxPossibleArcRadius < 0) maxPossibleArcRadius = 0;
      
      actualCornerRadius = Math.min(actualCornerRadius, maxPossibleArcRadius);
      if (actualCornerRadius < 0.1) actualCornerRadius = 0; 

      const points = [];
      for (let i = 0; i < polygonSides; i++) {
        const currentAngle = i * angleStep - Math.PI / 2; 
        points.push({
          x: centerX + shapeRadius * Math.cos(currentAngle),
          y: centerY + shapeRadius * Math.sin(currentAngle),
        });
      }

      if (actualCornerRadius === 0 || shapeRadius === 0) {
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < polygonSides; i++) {
          ctx.lineTo(points[i].x, points[i].y);
        }
      } else {
        const normalizeVector = (dx, dy) => {
          const len = Math.sqrt(dx * dx + dy * dy);
          return len === 0 ? [0, 0] : [dx / len, dy / len];
        };

        let p0_calc = points[polygonSides - 1];
        let p1_calc = points[0];
        let [v10x, v10y] = normalizeVector(p0_calc.x - p1_calc.x, p0_calc.y - p1_calc.y);
        ctx.moveTo(p1_calc.x + v10x * actualCornerRadius, p1_calc.y + v10y * actualCornerRadius);
        
        for (let i = 0; i < polygonSides; i++) {
          const currentVertex = points[i];
          const nextVertex = points[(i + 1) % polygonSides];
          const prevVertexLoop = points[(i + polygonSides - 1) % polygonSides]; 

          let [dx1_loop, dy1_loop] = normalizeVector(prevVertexLoop.x - currentVertex.x, prevVertexLoop.y - currentVertex.y);
          let [dx2_loop, dy2_loop] = normalizeVector(nextVertex.x - currentVertex.x, nextVertex.y - currentVertex.y);

          const t1x = currentVertex.x + dx1_loop * actualCornerRadius;
          const t1y = currentVertex.y + dy1_loop * actualCornerRadius;
          const t2x = currentVertex.x + dx2_loop * actualCornerRadius;
          const t2y = currentVertex.y + dy2_loop * actualCornerRadius;
          
          // Critical fix from previous: ensure lineTo is only skipped for the first point *after* the initial moveTo.
          // The very first "lineTo" in the loop IS needed if actualCornerRadius > 0, 
          // as moveTo positions at the start of the *first arc*. We then lineTo its start.
          // The conditional lineTo was causing issues. Simpler to always lineTo the start of the current arc segment.
          // ctx.lineTo(t1x, t1y); // This lineTo should actually be from the end of the PREVIOUS arc.
                               // The current structure: moveTo(start_of_arc_0), arcTo(v0, end_of_arc_0), lineTo(start_of_arc_1), arcTo(v1, end_of_arc_1)...

          // Corrected logic for rounded corners:
          // After moveTo for the first arc, subsequent segments should lineTo the start of their arc.
          // The arcTo command itself handles the curve.
          if (i > 0) { // For all vertices except the first one (whose arc start was handled by moveTo)
             ctx.lineTo(t1x, t1y);
          } else {
            // For the first vertex, we have already moveTo'd to the start of its arc.
            // We need to ensure the path starts correctly.
            // If we simply ctx.moveTo(t1x, t1y) for the *very first segment*,
            // then our "currentVertex" is point[0], prevVertexLoop is point[N-1].
            // The very first moveTo should be the point (t1x, t1y) of the *first* vertex.
            // The current `moveTo` is: `ctx.moveTo(p1_calc.x + v10x * actualCornerRadius, p1_calc.y + v10y * actualCornerRadius);`
            // where p1_calc = points[0], p0_calc = points[N-1]. This IS the start of the arc for points[0].
          }
          ctx.arcTo(currentVertex.x, currentVertex.y, t2x, t2y, actualCornerRadius);
        }
      }
      ctx.closePath();
    }

    if (fillEnabled) {
      const originalAlpha = ctx.globalAlpha;
      ctx.globalAlpha = fillOpacity;
      ctx.fillStyle = fillColor;
      ctx.fill();
      ctx.globalAlpha = originalAlpha;
    }

    if (strokeEnabled && effectiveStrokeWidth > 0) {
      ctx.strokeStyle = strokeColor;
      ctx.lineWidth = effectiveStrokeWidth;
      ctx.lineJoin = (actualCornerRadius > 0 && shapeType === ShapeType.POLYGON) ? "round" : "miter"; 
      ctx.stroke();
    }
  }

  function updateControlsUI() {
    dom.fillSettings.classList.toggle('hidden', !currentConfig.fillEnabled);
    dom.strokeSettings.classList.toggle('hidden', !currentConfig.strokeEnabled);
    const isPolygon = currentConfig.shapeType === ShapeType.POLYGON;
    dom.polygonSpecificSettings.classList.toggle('hidden', !isPolygon);

    dom.shapeType.value = currentConfig.shapeType;
    dom.size.value = currentConfig.size.toString();
    dom.fillEnabled.checked = currentConfig.fillEnabled;
    dom.fillColor.value = currentConfig.fillColor;
    dom.fillOpacity.value = currentConfig.fillOpacity.toString();
    dom.fillOpacityValue.textContent = currentConfig.fillOpacity.toFixed(2);
    dom.strokeEnabled.checked = currentConfig.strokeEnabled;
    dom.strokeColor.value = currentConfig.strokeColor;
    dom.strokeWidth.value = currentConfig.strokeWidth.toString();
    dom.polygonSides.value = currentConfig.polygonSides.toString();
    dom.polygonSidesValue.textContent = currentConfig.polygonSides.toString();
    dom.cornerRadiusLevel.value = currentConfig.cornerRadiusLevel;
  }

  function handleConfigChange(key, value) {
    let parsedValue = value;
    if (typeof DEFAULT_SHAPE_CONFIG[key] === 'number') {
      parsedValue = parseFloat(value);
      if (['polygonSides', 'size', 'strokeWidth'].includes(key)) {
        parsedValue = parseInt(value, 10);
      }
    } else if (typeof DEFAULT_SHAPE_CONFIG[key] === 'boolean') {
      parsedValue = typeof value === 'string' ? value === 'true' : Boolean(value);
    }
    currentConfig[key] = parsedValue;
    updateControlsUI();
    drawShape();
  }

  function initControls() {
    SIZES.forEach(s => {
      const opt = document.createElement('option');
      opt.value = s; opt.textContent = `${s} x ${s}`;
      dom.size.appendChild(opt);
    });
    STROKE_WIDTHS.forEach(sw => {
      const opt = document.createElement('option');
      opt.value = sw; opt.textContent = sw;
      dom.strokeWidth.appendChild(opt);
    });

    dom.shapeType.addEventListener('change', e => handleConfigChange('shapeType', e.target.value));
    dom.size.addEventListener('change', e => handleConfigChange('size', e.target.value));
    dom.fillEnabled.addEventListener('change', e => handleConfigChange('fillEnabled', e.target.checked));
    dom.fillColor.addEventListener('input', e => handleConfigChange('fillColor', e.target.value)); 
    dom.fillOpacity.addEventListener('input', e => {
        handleConfigChange('fillOpacity', e.target.value);
        dom.fillOpacityValue.textContent = parseFloat(e.target.value).toFixed(2);
    });
    dom.strokeEnabled.addEventListener('change', e => handleConfigChange('strokeEnabled', e.target.checked));
    dom.strokeColor.addEventListener('input', e => handleConfigChange('strokeColor', e.target.value)); 
    dom.strokeWidth.addEventListener('change', e => handleConfigChange('strokeWidth', e.target.value));
    dom.polygonSides.addEventListener('input', e => {
        handleConfigChange('polygonSides', e.target.value);
        dom.polygonSidesValue.textContent = e.target.value;
    });
    dom.cornerRadiusLevel.addEventListener('change', e => handleConfigChange('cornerRadiusLevel', e.target.value));
    
    updateControlsUI(); 
  }

  function applyTheme(theme) {
    const htmlEl = document.documentElement;
    if (theme === Theme.DARK) {
      htmlEl.classList.add('dark');
      dom.themeToggleButton.innerHTML = sunIconSvg;
      // Ensure SVG icon color is updated for dark mode
      dom.themeToggleButton.querySelector('svg')?.setAttribute('class', 'w-6 h-6 text-yellow-400');
      dom.themeToggleButton.setAttribute('aria-label', 'ライトモードに切り替え');
    } else {
      htmlEl.classList.remove('dark');
      dom.themeToggleButton.innerHTML = moonIconSvg;
      // Ensure SVG icon color is updated for light mode
      dom.themeToggleButton.querySelector('svg')?.setAttribute('class', 'w-6 h-6 text-slate-700');
      dom.themeToggleButton.setAttribute('aria-label', 'ダークモードに切り替え');
    }
    localStorage.setItem('theme', theme);
    currentTheme = theme;
  }

  function toggleTheme() {
    const newTheme = document.documentElement.classList.contains('dark') ? Theme.LIGHT : Theme.DARK;
    applyTheme(newTheme);
  }

  function initTheme() {
    const storedTheme = localStorage.getItem('theme');
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    let initialTheme = Theme.LIGHT;

    if (storedTheme === Theme.DARK || (!storedTheme && prefersDark)) {
      initialTheme = Theme.DARK;
    }
    // Inline script handles initial classList. This function sets up the button.
    applyTheme(initialTheme); // Call applyTheme to set button icon and currentTheme state
    dom.themeToggleButton.addEventListener('click', toggleTheme);
  }
  
  function handleDownload() {
    const dataUrl = dom.canvas.toDataURL('image/png');
    const link = document.createElement('a');
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    link.href = dataUrl;
    link.download = `${currentConfig.shapeType}_${currentConfig.size}x${currentConfig.size}_${timestamp}.png`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }

  document.addEventListener('DOMContentLoaded', () => {
    dom.currentYear.textContent = new Date().getFullYear();
    initTheme(); 
    initControls();
    Object.keys(DEFAULT_SHAPE_CONFIG).forEach(key => {
        if (dom[key]) {
            if (typeof DEFAULT_SHAPE_CONFIG[key] === 'boolean') {
                dom[key].checked = DEFAULT_SHAPE_CONFIG[key];
            } else {
                dom[key].value = DEFAULT_SHAPE_CONFIG[key].toString();
            }
        }
    });
    if(dom.fillOpacityValue) dom.fillOpacityValue.textContent = DEFAULT_SHAPE_CONFIG.fillOpacity.toFixed(2);
    if(dom.polygonSidesValue) dom.polygonSidesValue.textContent = DEFAULT_SHAPE_CONFIG.polygonSides.toString();

    // Initial show/hide based on default config
    // Sections are visible by default, updateControlsUI will hide them if necessary
    updateControlsUI(); 
    drawShape(); 
    dom.downloadButton.addEventListener('click', handleDownload);
  });

</script>
</body>
</html>
